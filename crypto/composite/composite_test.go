package composite_test

import (
	"bytes"
	"testing"

	"github.com/tendermint/tendermint/crypto/bls"
	"github.com/tendermint/tendermint/crypto/composite"
	"github.com/tendermint/tendermint/crypto/ed25519"
)

func TestPrivKeyComposite_Bytes(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	sk.Bytes()
}

func TestPrivKeyComposite_Equals(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk1 := composite.NewPrivKeyComposite(sign, vrf)
	if !sk1.Equals(sk1) {
		t.Errorf("%v", sk1.SignKey.Equals(sk1.SignKey))
		t.Errorf("%v", sk1.VrfKey.Equals(sk1.VrfKey))
		t.Errorf("Identical key is evaluated as different: %v != %v", sk1, sk1)
	}
	sk2 := composite.NewPrivKeyComposite(sign, vrf)
	if !sk1.Equals(sk2) || !sk2.Equals(sk1) {
		t.Errorf("The same keys are evaluated as different")
	}
	sk3 := composite.NewPrivKeyComposite(ed25519.GenPrivKey(), bls.GenPrivKey())
	if sk1.Equals(sk3) || sk3.Equals(sk1) {
		t.Errorf("The different keys are evaluated as the same")
	}
	if sk1.Equals(sign) || sk1.Equals(vrf) {
		t.Errorf("The different kind of keys are evaluated as the same")
	}
}

func TestPrivKeyComposite_Identity(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	if !bytes.Equal(sk.Identity().Bytes(), vrf.Bytes()) {
		t.Errorf("The identity key is not a vrf key")
	}
}

func TestPrivKeyComposite_PubKey(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	sk.PubKey()
}

func TestPrivKeyComposite_Sign(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	msg := []byte("hello, world")
	s1, err := sk.Sign(msg)
	if err != nil {
		t.Errorf("Fail to generate signature.")
	}
	s2, _ := sign.Sign(msg)
	if !bytes.Equal(s1, s2) {
		t.Errorf("The signature is not generated by sign key")
	}
}

func TestPrivKeyComposite_VRFProve(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	msg := []byte("hello, world")
	p, err := sk.VRFProve(msg)
	if err != nil {
		t.Errorf("Fail to generate proof.")
	}
	_, err = sk.PubKey().VRFVerify(p, msg)
	if err != nil {
		t.Errorf("Fail to verify the vrf proof.")
	}
}

func TestPubKeyComposite_Address(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	pk := sk.PubKey().(composite.PubKeyComposite)
	// check the byte-size is the same
	if len(pk.Address().Bytes()) != len(vrf.PubKey().Address().Bytes()) {
		t.Errorf("The address length is not compatible")
	}
}

func TestPubKeyComposite_Bytes(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	pk := sk.PubKey().(composite.PubKeyComposite)
	pk.Bytes()
}

func TestPubKeyComposite_Equals(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	pk1 := sk.PubKey().(composite.PubKeyComposite)
	if !pk1.Equals(pk1) {
		t.Errorf("Identical key is evaluated as different")
	}
	pk2 := sk.PubKey().(composite.PubKeyComposite)
	if !pk1.Equals(pk2) || !pk2.Equals(pk1) {
		t.Errorf("The same keys are evaluated as different")
	}
	sk3 := composite.NewPrivKeyComposite(ed25519.GenPrivKey(), bls.GenPrivKey())
	pk3 := sk3.PubKey().(composite.PubKeyComposite)
	if pk1.Equals(pk3) || pk3.Equals(pk1) {
		t.Errorf("The different keys are evaluated as the same")
	}
	if pk1.Equals(sign.PubKey()) || pk1.Equals(vrf.PubKey()) {
		t.Errorf("The different kind of keys are evaluated as the same")
	}
}

func TestPubKeyComposite_Identity(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	pk := sk.PubKey().(composite.PubKeyComposite)
	pk.Identity()
}

func TestPubKeyComposite_VerifyBytes(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	pk := sk.PubKey().(composite.PubKeyComposite)
	msg := []byte("hello, world")
	s, err := sk.Sign(msg)
	if err != nil {
		t.Errorf("Fail to generate signature.")
	}
	if !pk.VerifySignature(msg, s) {
		t.Errorf("Fail to verify signature.")
	}
	if pk.VerifySignature([]byte("brown fox"), s) {
		t.Errorf("Signature validation for the different messages is successful.")
	}
}

func TestPubKeyComposite_VRFVerify(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	pk := sk.PubKey().(composite.PubKeyComposite)
	msg := []byte("hello, world")
	proof, err := sk.VRFProve(msg)
	if err != nil {
		t.Errorf("Fail to generage vrf proof.")
	}
	output1, err := pk.VRFVerify(proof, msg)
	if err != nil {
		t.Errorf("Fail to verify vrf proof.")
	}
	output2, _ := vrf.PubKey().VRFVerify(proof, msg)
	if !bytes.Equal(output1, output2) {
		t.Errorf("Output is different from the VRF key.")
	}
}
