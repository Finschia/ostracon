package composite_test

import (
	"bytes"
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"

	"github.com/tendermint/tendermint/types"

	"github.com/tendermint/go-amino"

	"github.com/tendermint/tendermint/crypto"

	"github.com/tendermint/tendermint/crypto/bls"
	"github.com/tendermint/tendermint/crypto/composite"
	"github.com/tendermint/tendermint/crypto/ed25519"
)

func TestPrivKeyComposite_Bytes(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	sk.Bytes()
}

func TestPrivKeyComposite_Equals(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk1 := composite.NewPrivKeyComposite(sign, vrf)
	if !sk1.Equals(sk1) {
		t.Errorf("%v", sk1.SignKey.Equals(sk1.SignKey))
		t.Errorf("%v", sk1.VrfKey.Equals(sk1.VrfKey))
		t.Errorf("Identical key is evaluated as different: %v != %v", sk1, sk1)
	}
	sk2 := composite.NewPrivKeyComposite(sign, vrf)
	if !sk1.Equals(sk2) || !sk2.Equals(sk1) {
		t.Errorf("The same keys are evaluated as different")
	}
	sk3 := composite.NewPrivKeyComposite(ed25519.GenPrivKey(), bls.GenPrivKey())
	if sk1.Equals(sk3) || sk3.Equals(sk1) {
		t.Errorf("The different keys are evaluated as the same")
	}
	if sk1.Equals(sign) || sk1.Equals(vrf) {
		t.Errorf("The different kind of keys are evaluated as the same")
	}
}

func TestPrivKeyComposite_Identity(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	if sk.Identity() != vrf {
		t.Errorf("The identity key is not a vrf key")
	}
}

func TestPrivKeyComposite_PubKey(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	sk.PubKey()
}

func TestPrivKeyComposite_Sign(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	msg := []byte("hello, world")
	s1, err := sk.Sign(msg)
	if err != nil {
		t.Errorf("Fail to generate signature.")
	}
	s2, _ := sign.Sign(msg)
	if !bytes.Equal(s1, s2) {
		t.Errorf("The signature is not generated by sign key")
	}
}

func TestPrivKeyComposite_VRFProve(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	msg := []byte("hello, world")
	p, err := sk.VRFProve(msg)
	if err != nil {
		t.Errorf("Fail to generate proof.")
	}
	_, err = sk.PubKey().VRFVerify(p, msg)
	if err != nil {
		t.Errorf("Fail to verify the vrf proof.")
	}
}

func TestPubKeyComposite_Address(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	pk := sk.PubKey().(composite.PubKeyComposite)
	// check the byte-size is the same
	if len(pk.Address().Bytes()) != len(vrf.PubKey().Address().Bytes()) {
		t.Errorf("The address length is not compatible")
	}
}

func TestPubKeyComposite_Bytes(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	pk := sk.PubKey().(composite.PubKeyComposite)
	pk.Bytes()
}

func TestPubKeyComposite_Equals(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	pk1 := sk.PubKey().(composite.PubKeyComposite)
	if !pk1.Equals(pk1) {
		t.Errorf("Identical key is evaluated as different")
	}
	pk2 := sk.PubKey().(composite.PubKeyComposite)
	if !pk1.Equals(pk2) || !pk2.Equals(pk1) {
		t.Errorf("The same keys are evaluated as different")
	}
	sk3 := composite.NewPrivKeyComposite(ed25519.GenPrivKey(), bls.GenPrivKey())
	pk3 := sk3.PubKey().(composite.PubKeyComposite)
	if pk1.Equals(pk3) || pk3.Equals(pk1) {
		t.Errorf("The different keys are evaluated as the same")
	}
	if pk1.Equals(sign.PubKey()) || pk1.Equals(vrf.PubKey()) {
		t.Errorf("The different kind of keys are evaluated as the same")
	}
}

func TestPubKeyComposite_Identity(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	pk := sk.PubKey().(composite.PubKeyComposite)
	pk.Identity()
}

func TestPubKeyComposite_VerifyBytes(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	pk := sk.PubKey().(composite.PubKeyComposite)
	msg := []byte("hello, world")
	s, err := sk.Sign(msg)
	if err != nil {
		t.Errorf("Fail to generate signature.")
	}
	if !pk.VerifyBytes(msg, s) {
		t.Errorf("Fail to verify signature.")
	}
	if pk.VerifyBytes([]byte("brown fox"), s) {
		t.Errorf("Signature validation for the different messages is successful.")
	}
}

func TestPubKeyComposite_VRFVerify(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	pk := sk.PubKey().(composite.PubKeyComposite)
	msg := []byte("hello, world")
	proof, err := sk.VRFProve(msg)
	if err != nil {
		t.Errorf("Fail to generage vrf proof.")
	}
	output1, err := pk.VRFVerify(proof, msg)
	if err != nil {
		t.Errorf("Fail to verify vrf proof.")
	}
	output2, _ := vrf.PubKey().VRFVerify(proof, msg)
	if !bytes.Equal(output1, output2) {
		t.Errorf("Output is different from the VRF key.")
	}
}

func TestMy(t *testing.T) {
	blsKey := bls.PrivKeyBLS12{}
	vrfKey := ed25519.PrivKeyEd25519{}
	blsKeyBinary := []byte{74, 34, 180, 175, 203, 92, 237, 211, 145, 23, 55, 92, 100, 6, 43, 241, 39,
		218, 125, 31, 130, 120, 96, 248, 193, 51, 90, 185, 56, 18, 254, 90}
	vrfKeyBinary := []byte{190, 183, 71, 79, 63, 127, 146, 85, 204, 90, 84, 59, 1, 183, 55, 243, 215, 132, 125, 80,
		200, 246, 24, 142, 147, 52, 111, 98, 204, 19, 75, 137, 5, 246, 217, 51, 191, 52, 138, 206, 156, 9, 144, 130,
		169, 214, 112, 138, 61, 41, 253, 76, 242, 178, 34, 145, 143, 159, 194, 70, 94, 47, 101, 40}
	copy(blsKey[:], blsKeyBinary)
	copy(vrfKey[:], vrfKeyBinary)
	privKey := composite.NewPrivKeyComposite(crypto.PrivKey(blsKey), crypto.PrivKey(vrfKey))

	pubKey := privKey.PubKey()
	address := pubKey.Address()

	sampleVote := types.Vote{}
	sampleVote.Height = 1
	sampleVote.ValidatorIndex = 1
	sampleVote.BlockID = types.BlockID{
		Hash:        address.Bytes(),
		PartsHeader: types.PartSetHeader{Total: 1, Hash: address.Bytes()}}
	sampleVote.Round = 0
	sampleVote.Timestamp = time.Date(1970, 1, 1, 0, 0, 0, 0, time.UTC)
	sampleVote.Type = types.PrevoteType
	sampleVote.ValidatorAddress = address

	signBytes := sampleVote.SignBytes("chainid")
	sampleVote.Signature, _ = privKey.Sign(signBytes)
	t.Logf("pubKey: %X", pubKey.Bytes())
	t.Logf("vote: %X", sampleVote.SignBytes("chainid"))
	t.Logf("vote signature: %X", sampleVote.Signature)
	pubKeyBytes, _ := hex.DecodeString("D68FFBC130B25FCC05C88BE1D2CF5D53BC8E07A67C43F0FC1CD210A7E885FADA369B959F" +
		"A74E7FF3ACF4BF9A96353D170B9D5C69701624DE642005F6D933BF348ACE9C099082A9D6708A3D29FD4CF2B222918F9FC2465E2F6528")
	voteBytes, _ := hex.DecodeString("46080111010000000000000022300A14D9FB38E2F84230D6165FAD29072C9318EED18F5F12" +
		"180A14D9FB38E2F84230D6165FAD29072C9318EED18F5F10013207636861696E6964")
	signatureBytes, _ := hex.DecodeString("83AD3675D4AB4E0C3F9052BF29BE26A209258690DD89D619E64206A2FFFA7E3E8626D" +
		"546340B44A1DCE4B39543630518123316C5A40EDFB3DE38015C6E1357C14DECD9A9A97949DAF40BDA755DC866AFD12963D85583C2E6" +
		"49138BBCAA27A9B0")
	assert.Equal(t, pubKey.Bytes(), pubKeyBytes)
	assert.Equal(t, sampleVote.SignBytes("chainid"), voteBytes)
	assert.Equal(t, sampleVote.Signature, signatureBytes)
	verifying := pubKey.VerifyBytes(sampleVote.SignBytes("chainid"), sampleVote.Signature)
	assert.True(t, verifying)
}

func TestEnvironmentalCompatibility(t *testing.T) {
	var cdc = amino.NewCodec()
	cdc.RegisterInterface((*crypto.PrivKey)(nil), nil)
	cdc.RegisterInterface((*crypto.PubKey)(nil), nil)
	cdc.RegisterConcrete(bls.PubKeyBLS12{}, bls.PubKeyAminoName, nil)
	cdc.RegisterConcrete(bls.PrivKeyBLS12{}, bls.PrivKeyAminoName, nil)
	cdc.RegisterConcrete(ed25519.PubKeyEd25519{}, ed25519.PubKeyAminoName, nil)
	cdc.RegisterConcrete(ed25519.PrivKeyEd25519{}, ed25519.PrivKeyAminoName, nil)
	cdc.RegisterConcrete(composite.PubKeyComposite{}, composite.PubKeyCompositeAminoName, nil)
	cdc.RegisterConcrete(composite.PrivKeyComposite{}, composite.PrivKeyCompositeAminoName, nil)

	t.Run("MarshalCompositeKey", func(t *testing.T) {
		privKey := composite.GenPrivKey()
		privKeyBytes, err := cdc.MarshalBinaryBare(privKey)
		if err != nil {
			t.Fatal(err)
		}
		fmt.Printf("PrivKeyComposite: %s\n", hex.EncodeToString(privKeyBytes))
	})

	t.Run("The same signature is generated from the same key binary for any runtime env", func(t *testing.T) {
		privKeyBytes, err := hex.DecodeString("9f3ee8f00a25eaecf03f203761de9e836bed524dd0b2737c56b69f69672c2b3e40" +
			"31b74817474c62b204221245a328891040c69e39ac62519a09895babbb84d6a3a8ea4b69a61760e0c0b04052e252c272ef478fb" +
			"da7337ad81ed4202d2bb3ad8240e17248aae2dc169b2e12b45b366d09be")
		if err != nil {
			t.Fatal(err)
		}
		compositePrivKey := composite.PrivKeyComposite{}
		if err := cdc.UnmarshalBinaryBare(privKeyBytes, &compositePrivKey); err != nil {
			t.Fatal(err)
		}
		msg := []byte("hello, world")
		actual, err := compositePrivKey.Sign(msg)
		if err != nil {
			t.Fatal(err)
		}
		expected, err := hex.DecodeString("894d184a975aed6b442991e2ce60f7b39d6e810bde5ccb5d5d45dd6e461028339aa43" +
			"2d027462f8ce7a5cf7db71ddabb0446cbb90ac817c26cc65614536cf99a9b739592dce467cc3d26bff63f5509157c2daa3b485" +
			"afa3d2efab804c16f271d")
		if err != nil {
			t.Fatal(err)
		}
		if !bytes.Equal(expected, actual) {
			t.Logf("Expected Signature: %s (%d bytes)", hex.EncodeToString(expected), len(expected))
			t.Logf("Actual   Signature: %s (%d bytes)", hex.EncodeToString(actual), len(actual))
			t.Errorf("Signatures generated from the same key and message are different than expected")
		}
	})

	// https://github.com/line/tendermint/issues/121
	t.Run("A reproduction test of issue #121", func(t *testing.T) {

		// restore BLS private key from base64 string in priv_validator_key.json
		blsPrivKey := bls.PrivKeyBLS12{}
		blsPrivKeyBytes, err := base64.StdEncoding.DecodeString("BpqODFajV6NnQhBfT8ERyvwyqPoZS664e1v35sfr76g=")
		if err != nil {
			t.Fatal(err)
		} else if len(blsPrivKeyBytes) != bls.PrivKeyBLS12Size {
			t.Fatalf("fixed private key size: %d != %d", bls.PrivKeyBLS12Size, len(blsPrivKeyBytes))
		}
		copy(blsPrivKey[:], blsPrivKeyBytes)

		// restore Ed25519 private key from base64 string in priv_validator_key.json
		ed25519PrivKey := ed25519.PrivKeyEd25519{}
		ed25519PrivKeyBytes, err := base64.StdEncoding.DecodeString("TGb5K4TbD1XdNd0HGEt7I6quhTJ2aSckgPLLBKs8hDUC" +
			"4Wh8kfEmnRUeMYtR8V0UfNwQyTYqGupZeyIhJcV1TA==")
		if err != nil {
			t.Fatal(err)
		} else if len(ed25519PrivKeyBytes) != len(ed25519PrivKey) {
			t.Fatalf("fixed private key size: %d != %d", len(ed25519PrivKey), len(ed25519PrivKeyBytes))
		}
		copy(ed25519PrivKey[:], ed25519PrivKeyBytes)

		// compare addresses to assumed value
		compositePrivKey := composite.NewPrivKeyComposite(blsPrivKey, ed25519PrivKey)
		compositePubKey := compositePrivKey.PubKey()
		address, err := hex.DecodeString("7A68265205CB115AE35A13515C423F1721E87BB4")
		if err != nil {
			t.Fatal(err)
		}
		if !bytes.Equal(address, compositePubKey.Address()) {
			t.Fatalf("addresses didn't match: %s", hex.EncodeToString(compositePubKey.Address()))
		}

		// compare generated signature to assumed value
		message, err := hex.DecodeString("44080111010000000000000022300A147A68265205CB115AE35A13515C423F1721E87BB" +
			"412180A147A68265205CB115AE35A13515C423F1721E87BB410013205636861696E")
		if err != nil {
			t.Fatal(err)
		}
		signature, err := compositePrivKey.Sign(message)
		if err != nil {
			t.Fatal(err)
		}
		expectedSig, err := hex.DecodeString("A97BA8640BC3A1E05A2F4979D7FCF21DAA2A5D4AC64E16F76C6B1CBD646D6BF6EE6" +
			"DF18B212CAE18D100A7CA0BC3EF8A17B3E7B82ED4105BEABA9F3B857B067E73D9251962B5BC4CF39B10547287DF8ADB9ED24AF7" +
			"AA834114AE20B0BB6DD98D")
		if err != nil {
			t.Fatal(err)
		}
		if !bytes.Equal(expectedSig, signature) {
			t.Logf("Address: %s", hex.EncodeToString(address))
			t.Logf("Message: %s (%d bytes)", hex.EncodeToString(message), len(message))
			t.Logf("Expected Signature: %s (%d bytes)", hex.EncodeToString(expectedSig), len(expectedSig))
			t.Logf("Actual   Signature: %s (%d bytes)", hex.EncodeToString(signature), len(signature))
			t.Errorf("Different signatures are made for the same message with the same private key.")
		}
	})
}
