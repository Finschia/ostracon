package composite_test

import (
	"bytes"
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"testing"

	tmjson "github.com/line/ostracon/libs/json"

	"github.com/line/ostracon/crypto/bls"
	"github.com/line/ostracon/crypto/composite"
	"github.com/line/ostracon/crypto/ed25519"
)

func TestPrivKeyComposite_Bytes(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	sk.Bytes()
}

func TestPrivKeyComposite_Equals(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk1 := composite.NewPrivKeyComposite(sign, vrf)
	if !sk1.Equals(sk1) {
		t.Errorf("%v", sk1.SignKey.Equals(sk1.SignKey))
		t.Errorf("%v", sk1.VrfKey.Equals(sk1.VrfKey))
		t.Errorf("Identical key is evaluated as different: %v != %v", sk1, sk1)
	}
	sk2 := composite.NewPrivKeyComposite(sign, vrf)
	if !sk1.Equals(sk2) || !sk2.Equals(sk1) {
		t.Errorf("The same keys are evaluated as different")
	}
	sk3 := composite.NewPrivKeyComposite(ed25519.GenPrivKey(), bls.GenPrivKey())
	if sk1.Equals(sk3) || sk3.Equals(sk1) {
		t.Errorf("The different keys are evaluated as the same")
	}
	if sk1.Equals(sign) || sk1.Equals(vrf) {
		t.Errorf("The different kind of keys are evaluated as the same")
	}
}

func TestPrivKeyComposite_Identity(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	if !bytes.Equal(sk.Identity().Bytes(), vrf.Bytes()) {
		t.Errorf("The identity key is not a vrf key")
	}
}

func TestPrivKeyComposite_PubKey(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	sk.PubKey()
}

func TestPrivKeyComposite_Sign(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	msg := []byte("hello, world")
	s1, err := sk.Sign(msg)
	if err != nil {
		t.Errorf("Fail to generate signature.")
	}
	s2, _ := sign.Sign(msg)
	if !bytes.Equal(s1, s2) {
		t.Errorf("The signature is not generated by sign key")
	}
}

func TestPrivKeyComposite_VRFProve(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	msg := []byte("hello, world")
	p, err := sk.VRFProve(msg)
	if err != nil {
		t.Errorf("Fail to generate proof.")
	}
	_, err = sk.PubKey().VRFVerify(p, msg)
	if err != nil {
		t.Errorf("Fail to verify the vrf proof.")
	}
}

func TestPubKeyComposite_Address(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	pk := sk.PubKey().(composite.PubKey)
	// check the byte-size is the same
	if len(pk.Address().Bytes()) != len(vrf.PubKey().Address().Bytes()) {
		t.Errorf("The address length is not compatible")
	}
}

func TestPubKeyComposite_Bytes(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	pk := sk.PubKey().(composite.PubKey)
	pk.Bytes()
}

func TestPubKeyComposite_Equals(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	pk1 := sk.PubKey().(composite.PubKey)
	if !pk1.Equals(pk1) {
		t.Errorf("Identical key is evaluated as different")
	}
	pk2 := sk.PubKey().(composite.PubKey)
	if !pk1.Equals(pk2) || !pk2.Equals(pk1) {
		t.Errorf("The same keys are evaluated as different")
	}
	sk3 := composite.NewPrivKeyComposite(ed25519.GenPrivKey(), bls.GenPrivKey())
	pk3 := sk3.PubKey().(composite.PubKey)
	if pk1.Equals(pk3) || pk3.Equals(pk1) {
		t.Errorf("The different keys are evaluated as the same")
	}
	if pk1.Equals(sign.PubKey()) || pk1.Equals(vrf.PubKey()) {
		t.Errorf("The different kind of keys are evaluated as the same")
	}
}

func TestPubKeyComposite_Identity(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	pk := sk.PubKey().(composite.PubKey)
	pk.Identity()
}

func TestPubKeyComposite_VerifyBytes(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	pk := sk.PubKey().(composite.PubKey)
	msg := []byte("hello, world")
	s, err := sk.Sign(msg)
	if err != nil {
		t.Errorf("Fail to generate signature.")
	}
	if !pk.VerifySignature(msg, s) {
		t.Errorf("Fail to verify signature.")
	}
	if pk.VerifySignature([]byte("brown fox"), s) {
		t.Errorf("Signature validation for the different messages is successful.")
	}
}

func TestPubKeyComposite_VRFVerify(t *testing.T) {
	sign := bls.GenPrivKey()
	vrf := ed25519.GenPrivKey()
	sk := composite.NewPrivKeyComposite(sign, vrf)
	pk := sk.PubKey().(composite.PubKey)
	msg := []byte("hello, world")
	proof, err := sk.VRFProve(msg)
	if err != nil {
		t.Errorf("Fail to generage vrf proof.")
	}
	output1, err := pk.VRFVerify(proof, msg)
	if err != nil {
		t.Errorf("Fail to verify vrf proof.")
	}
	output2, _ := vrf.PubKey().VRFVerify(proof, msg)
	if !bytes.Equal(output1, output2) {
		t.Errorf("Output is different from the VRF key.")
	}
}

func TestEnvironmentalCompatibility(t *testing.T) {
	t.Run("The same signature is generated from the same key binary for any runtime env", func(t *testing.T) {
		privKeyJSON := fmt.Sprintf(
			"{\"type\":\"%s\",\"value\":{"+
				"\"sign\":{\"type\":\"%s\",\"value\":\"%s\"},"+
				"\"vrf\":{\"type\":\"%s\",\"value\":\"%s\"}}}",
			composite.PrivKeyName,
			bls.PrivKeyName, "FXBs3F3g3FGyDY8P8ipK8t6jwFgJR/jvUnYwiKLWnYQ=",
			ed25519.PrivKeyName, "IzLJPy6KFiEGbV7SvJAIUBzYbjOpgtdKU+RFsGWYknuTZdNPe6iQzthTvKj4ZU1rkLqXg6ofcej1/89NXexfww==")
		compositePrivKey := composite.PrivKey{}
		err := tmjson.Unmarshal([]byte(privKeyJSON), &compositePrivKey)
		if err != nil {
			t.Fatal(err)
		}

		msg := []byte("hello, world")
		actual, err := compositePrivKey.Sign(msg)
		if err != nil {
			t.Fatal(err)
		}
		expected, err := hex.DecodeString("880b6db7a1be536e1057b34552325dd4ae6acdab4aa833f196c9d7c6d10973c9bbfb4a" +
			"7f6a482287698a26007be82047157e38c27f8994463b12788f7dde86a6057493543c7922141248845b4f63b4bcf207e4fc92b1d" +
			"c4cff8d06d44e5d8109")
		if err != nil {
			t.Fatal(err)
		}
		if !bytes.Equal(expected, actual) {
			t.Logf("Expected Signature: %s (%d bytes)", hex.EncodeToString(expected), len(expected))
			t.Logf("Actual   Signature: %s (%d bytes)", hex.EncodeToString(actual), len(actual))
			t.Errorf("Signatures generated from the same key and message are different than expected")
		}
	})

	// https://github.com/line/ostracon/issues/121
	t.Run("A reproduction test of issue #121", func(t *testing.T) {

		// restore BLS private key from base64 string in priv_validator_key.json
		blsPrivKey := bls.PrivKey{}
		blsPrivKeyBytes, err := base64.StdEncoding.DecodeString("BpqODFajV6NnQhBfT8ERyvwyqPoZS664e1v35sfr76g=")
		if err != nil {
			t.Fatal(err)
		} else if len(blsPrivKeyBytes) != bls.PrivKeySize {
			t.Fatalf("fixed private key size: %d != %d", len(blsPrivKeyBytes), bls.PrivKeySize)
		}
		copy(blsPrivKey[:], blsPrivKeyBytes)

		// restore Ed25519 private key from base64 string in priv_validator_key.json
		ed25519PrivKeyBytes, err := base64.StdEncoding.DecodeString("TGb5K4TbD1XdNd0HGEt7I6quhTJ2aSckgPLLBKs8hDUC" +
			"4Wh8kfEmnRUeMYtR8V0UfNwQyTYqGupZeyIhJcV1TA==")
		if err != nil {
			t.Fatal(err)
		} else if len(ed25519PrivKeyBytes) != ed25519.PrivateKeySize {
			t.Fatalf("fixed private key size: %d != %d", len(ed25519PrivKeyBytes), ed25519.PrivateKeySize)
		}
		var ed25519PrivKey ed25519.PrivKey = ed25519PrivKeyBytes

		// compare addresses to assumed value
		compositePrivKey := composite.NewPrivKeyComposite(blsPrivKey, ed25519PrivKey)
		compositePubKey := compositePrivKey.PubKey()
		address, err := hex.DecodeString("712988cd548e7c6858aa3e836e02e8f836cdb7a9")
		if err != nil {
			t.Fatal(err)
		}
		if !bytes.Equal(address, compositePubKey.Address()) {
			t.Errorf("addresses didn't match: %s", hex.EncodeToString(compositePubKey.Address()))
		}

		// compare generated signature to assumed value
		message, err := hex.DecodeString("44080111010000000000000022300A147A68265205CB115AE35A13515C423F1721E87BB" +
			"412180A147A68265205CB115AE35A13515C423F1721E87BB410013205636861696E")
		if err != nil {
			t.Fatal(err)
		}
		signature, err := compositePrivKey.Sign(message)
		if err != nil {
			t.Fatal(err)
		}
		expectedSig, err := hex.DecodeString("a00a8a8143fff615e3df98e9b4a493b0ffc5cf1cee14c55d4c667c34651392331c4d" +
			"5a1bf0a15d018262d61f74a59cc80775217b81363796e50aac7ce7542424a2eb84fbaf787f7a1c00229682ac4bb0a45f67cdf43f" +
			"b21b091f25a0a8bd51ae")
		if err != nil {
			t.Fatal(err)
		}
		if !bytes.Equal(expectedSig, signature) {
			t.Logf("Address: %s", hex.EncodeToString(address))
			t.Logf("Message: %s (%d bytes)", hex.EncodeToString(message), len(message))
			t.Logf("Expected Signature: %s (%d bytes)", hex.EncodeToString(expectedSig), len(expectedSig))
			t.Logf("Actual   Signature: %s (%d bytes)", hex.EncodeToString(signature), len(signature))
			t.Errorf("Different signatures are made for the same message with the same private key.")
		}
	})
}
